{"version":3,"sources":["../../src/utils/misc.js"],"names":["createProjection","paths","exclusive","mixingTypes","type","projection","split","startsWith","some","path","map","substring","Object","keys","Error","shouldRestoreValue","fullProperty","indexOf","field","shouldProcessObjectRecursively","value","filterObjectRecursively","payload","initialObject","rootProperty","reduce","prev","payloadProperty","payloadValue","mergeValue","result","Array","isArray","payloadItem","index","initialRowObject","find","mergeItem","id","undefined","filterObject","object","newProjection"],"mappings":"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","file":"misc.js","sourcesContent":["export const createProjection = projection => {\r\n  let paths, exclusive, mixingTypes;\r\n  const type = typeof (projection);\r\n  if (type === 'string') {\r\n    paths = projection.split(' ');\r\n    exclusive = paths[0].startsWith('-');\r\n    mixingTypes = paths.some(path => path.startsWith('-') === !exclusive);\r\n    paths = paths.map(path => exclusive ? path.substring(1) : path);\r\n  } else if (type === 'object') {\r\n    paths = Object.keys(projection);\r\n    exclusive = projection[paths[0]] === 0;\r\n    mixingTypes = paths.some(path => projection[path] === (exclusive ? 1 : 0));\r\n  } else {\r\n    throw new Error('Projection must be either string or object');\r\n  }\r\n  if (mixingTypes) throw new Error('It\\'s not allowed to mix inclusive and exclusive paths in projection');\r\n  return { exclusive, paths };\r\n};\r\n\r\nconst shouldRestoreValue = (fullProperty, { exclusive, paths }) => {\r\n  return (exclusive && paths.indexOf(fullProperty) > -1) ||\r\n    (!exclusive && paths.indexOf(fullProperty) === -1 &&\r\n      !paths.some(field => field.startsWith(fullProperty)));\r\n};\r\n\r\nconst shouldProcessObjectRecursively = (value, paths, fullProperty) => {\r\n  return typeof (value) === \"object\" && paths.some(path => path.startsWith(fullProperty + \".\"));\r\n};\r\n\r\nconst filterObjectRecursively = (payload, initialObject = {}, rootProperty, { paths, exclusive }) => {\r\n  return Object.keys(payload).reduce((prev, payloadProperty) => {\r\n    const payloadValue = payload[payloadProperty];\r\n    const mergeValue = initialObject[payloadProperty];\r\n    const fullProperty = `${rootProperty ? rootProperty + \".\" : \"\"}${payloadProperty}`;\r\n    let result;\r\n    if (shouldRestoreValue(fullProperty, { paths, exclusive })) {\r\n      result = mergeValue;\r\n    } else if (Array.isArray(payloadValue)) {\r\n      result = payloadValue.map((payloadItem, index) => {\r\n        if (!shouldProcessObjectRecursively(payloadValue, paths, fullProperty)) return payloadItem;\r\n        // Looking row with same id in `initialObject`\r\n        const initialRowObject = mergeValue && mergeValue.find(mergeItem => mergeItem.id === payloadItem.id);\r\n        return filterObjectRecursively(payloadValue[index], initialRowObject, fullProperty, { paths, exclusive });\r\n      });\r\n    } else if (shouldProcessObjectRecursively(payloadValue, paths, fullProperty)) {\r\n      result = filterObjectRecursively(payloadValue, mergeValue, fullProperty, { paths, exclusive });\r\n    } else {\r\n      result = payloadValue;\r\n    }\r\n    return (result !== undefined && { ...prev, [payloadProperty]: result }) || prev;\r\n  }, {});\r\n};\r\n\r\nexport const filterObject = (object, projection, initialObject) => {\r\n  const newProjection = createProjection(projection);\r\n  return filterObjectRecursively(object, initialObject, \"\", newProjection);\r\n};"]}