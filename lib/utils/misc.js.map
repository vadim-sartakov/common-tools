{"version":3,"sources":["../../src/utils/misc.js"],"names":["shouldRestoreValue","fullProperty","exclusive","fields","undefined","Object","keys","some","field","startsWith","shouldProcessObjectRecursively","value","filterObjectRecursively","payload","initialObject","rootProperty","reduce","prev","payloadProperty","payloadValue","mergeValue","result","Array","isArray","map","payloadItem","index","initialRowObject","find","mergeItem","id","isExclusiveProjection","filterObject","object"],"mappings":"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","file":"misc.js","sourcesContent":["const shouldRestoreValue = (fullProperty, { exclusive, fields }) => {\n    return ( exclusive && fields[fullProperty] === 0 ) ||\n            ( !exclusive && fields[fullProperty] === undefined &&\n                    !Object.keys(fields).some(field => field.startsWith(fullProperty)) );\n};\n\nconst shouldProcessObjectRecursively = (value, fields, fullProperty) => {\n    return typeof(value) === \"object\" && Object.keys(fields).some(field => field.startsWith(fullProperty));\n};\n\nconst filterObjectRecursively = (payload, initialObject = {}, rootProperty, { fields, exclusive }) => {\n    return Object.keys(payload).reduce((prev, payloadProperty) => {\n        const payloadValue = payload[payloadProperty];\n        const mergeValue = initialObject[payloadProperty];\n        const fullProperty = `${rootProperty ? rootProperty + \".\" : \"\"}${payloadProperty}`;\n        let result;\n        if ( shouldRestoreValue(fullProperty, { fields, exclusive }) ) {\n            result = mergeValue;\n        } else if(Array.isArray(payloadValue)) {\n            result = payloadValue.map( ( payloadItem, index ) => {\n                if (!shouldProcessObjectRecursively(payloadValue, fields, fullProperty)) return payloadItem;\n                // Looking row with same id in `initialObject`\n                const initialRowObject = mergeValue && mergeValue.find(mergeItem => mergeItem.id === payloadItem.id);\n                return filterObjectRecursively(payloadValue[index], initialRowObject, fullProperty, { fields, exclusive });\n            });\n        } else if ( shouldProcessObjectRecursively(payloadValue, fields, fullProperty) ) {\n            result = filterObjectRecursively(payloadValue, mergeValue, fullProperty, { fields, exclusive });\n        }  else {\n            result = payloadValue;\n        }\n        return ( result !== undefined && { ...prev, [payloadProperty]: result } ) || prev;\n    }, { });\n};\n\nconst isExclusiveProjection = fields => {\n    return fields[Object.keys(fields)[0]] === 0;\n};\n\nexport const filterObject = (object, fields, initialObject) => {\n    const exclusive = isExclusiveProjection(fields);\n    return filterObjectRecursively(object, initialObject, \"\", { fields, exclusive });\n};"]}