{"version":3,"sources":["../../src/utils/misc.js"],"names":["shouldRestoreValue","fullProperty","exclusive","fields","undefined","Object","keys","some","field","startsWith","shouldProcessObjectRecursively","value","filterObjectRecursively","payload","initialObject","rootProperty","reduce","prev","payloadProperty","payloadValue","mergeValue","result","Array","isArray","map","payloadItem","index","initialRowObject","find","mergeItem","id","isExclusiveProjection","filterObject","object"],"mappings":"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","file":"misc.js","sourcesContent":["const shouldRestoreValue = (fullProperty, { exclusive, fields }) => {\r\n    return ( exclusive && fields[fullProperty] === 0 ) ||\r\n            ( !exclusive && fields[fullProperty] === undefined &&\r\n                    !Object.keys(fields).some(field => field.startsWith(fullProperty)) );\r\n};\r\n\r\nconst shouldProcessObjectRecursively = (value, fields, fullProperty) => {\r\n    return typeof(value) === \"object\" && Object.keys(fields).some(field => field.startsWith(fullProperty + \".\"));\r\n};\r\n\r\nconst filterObjectRecursively = (payload, initialObject = {}, rootProperty, { fields, exclusive }) => {\r\n    return Object.keys(payload).reduce((prev, payloadProperty) => {\r\n        const payloadValue = payload[payloadProperty];\r\n        const mergeValue = initialObject[payloadProperty];\r\n        const fullProperty = `${rootProperty ? rootProperty + \".\" : \"\"}${payloadProperty}`;\r\n        let result;\r\n        if ( shouldRestoreValue(fullProperty, { fields, exclusive }) ) {\r\n            result = mergeValue;\r\n        } else if(Array.isArray(payloadValue)) {\r\n            result = payloadValue.map( ( payloadItem, index ) => {\r\n                if (!shouldProcessObjectRecursively(payloadValue, fields, fullProperty)) return payloadItem;\r\n                // Looking row with same id in `initialObject`\r\n                const initialRowObject = mergeValue && mergeValue.find(mergeItem => mergeItem.id === payloadItem.id);\r\n                return filterObjectRecursively(payloadValue[index], initialRowObject, fullProperty, { fields, exclusive });\r\n            });\r\n        } else if ( shouldProcessObjectRecursively(payloadValue, fields, fullProperty) ) {\r\n            result = filterObjectRecursively(payloadValue, mergeValue, fullProperty, { fields, exclusive });\r\n        }  else {\r\n            result = payloadValue;\r\n        }\r\n        return ( result !== undefined && { ...prev, [payloadProperty]: result } ) || prev;\r\n    }, { });\r\n};\r\n\r\nconst isExclusiveProjection = fields => {\r\n    return fields[Object.keys(fields)[0]] === 0;\r\n};\r\n\r\nexport const filterObject = (object, fields, initialObject) => {\r\n    const exclusive = isExclusiveProjection(fields);\r\n    return filterObjectRecursively(object, initialObject, \"\", { fields, exclusive });\r\n};"]}