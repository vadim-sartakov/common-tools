{"version":3,"sources":["../../src/utils/misc.js"],"names":["shouldRestoreValue","fullProperty","exclusive","fields","undefined","Object","keys","some","field","startsWith","shouldProcessObjectRecursively","value","filterObjectRecursively","payload","initialObject","rootProperty","reduce","prev","payloadProperty","payloadValue","mergeValue","result","Array","isArray","map","payloadItem","index","initialRowObject","find","mergeItem","id","isExclusiveProjection","filterObject","object","projectionMeta","projection","paths","isExclusive","mixingTypes","type","split","path","accumulator","substring","Error"],"mappings":";;;;;;;;;;;;AAAA,IAAMA,qBAAqB,SAArBA,kBAAqB,CAACC,YAAD,QAAyC;AAAA,MAAxBC,SAAwB,QAAxBA,SAAwB;AAAA,MAAbC,MAAa,QAAbA,MAAa;;AAClE,SAAQD,aAAaC,OAAOF,YAAP,MAAyB,CAAvC,IACJ,CAACC,SAAD,IAAcC,OAAOF,YAAP,MAAyBG,SAAvC,IACC,CAACC,OAAOC,IAAP,CAAYH,MAAZ,EAAoBI,IAApB,CAAyB;AAAA,WAASC,MAAMC,UAAN,CAAiBR,YAAjB,CAAT;AAAA,GAAzB,CAFL;AAGD,CAJD;;AAMA,IAAMS,iCAAiC,SAAjCA,8BAAiC,CAACC,KAAD,EAAQR,MAAR,EAAgBF,YAAhB,EAAiC;AACtE,SAAO,QAAQU,KAAR,yCAAQA,KAAR,OAAmB,QAAnB,IAA+BN,OAAOC,IAAP,CAAYH,MAAZ,EAAoBI,IAApB,CAAyB;AAAA,WAASC,MAAMC,UAAN,CAAiBR,eAAe,GAAhC,CAAT;AAAA,GAAzB,CAAtC;AACD,CAFD;;AAIA,IAAMW,0BAA0B,SAA1BA,uBAA0B,CAACC,OAAD,EAAsE;AAAA,MAA5DC,aAA4D,uEAA5C,EAA4C;AAAA,MAAxCC,YAAwC;AAAA;AAAA,MAAxBZ,MAAwB,SAAxBA,MAAwB;AAAA,MAAhBD,SAAgB,SAAhBA,SAAgB;;AACpG,SAAOG,OAAOC,IAAP,CAAYO,OAAZ,EAAqBG,MAArB,CAA4B,UAACC,IAAD,EAAOC,eAAP,EAA2B;AAC5D,QAAMC,eAAeN,QAAQK,eAAR,CAArB;AACA,QAAME,aAAaN,cAAcI,eAAd,CAAnB;AACA,QAAMjB,qBAAkBc,eAAeA,eAAe,GAA9B,GAAoC,EAAtD,IAA2DG,eAAjE;AACA,QAAIG,eAAJ;AACA,QAAIrB,mBAAmBC,YAAnB,EAAiC,EAAEE,cAAF,EAAUD,oBAAV,EAAjC,CAAJ,EAA6D;AAC3DmB,eAASD,UAAT;AACD,KAFD,MAEO,IAAIE,MAAMC,OAAN,CAAcJ,YAAd,CAAJ,EAAiC;AACtCE,eAASF,aAAaK,GAAb,CAAiB,UAACC,WAAD,EAAcC,KAAd,EAAwB;AAChD,YAAI,CAAChB,+BAA+BS,YAA/B,EAA6ChB,MAA7C,EAAqDF,YAArD,CAAL,EAAyE,OAAOwB,WAAP;AACzE;AACA,YAAME,mBAAmBP,cAAcA,WAAWQ,IAAX,CAAgB;AAAA,iBAAaC,UAAUC,EAAV,KAAiBL,YAAYK,EAA1C;AAAA,SAAhB,CAAvC;AACA,eAAOlB,wBAAwBO,aAAaO,KAAb,CAAxB,EAA6CC,gBAA7C,EAA+D1B,YAA/D,EAA6E,EAAEE,cAAF,EAAUD,oBAAV,EAA7E,CAAP;AACD,OALQ,CAAT;AAMD,KAPM,MAOA,IAAIQ,+BAA+BS,YAA/B,EAA6ChB,MAA7C,EAAqDF,YAArD,CAAJ,EAAwE;AAC7EoB,eAAST,wBAAwBO,YAAxB,EAAsCC,UAAtC,EAAkDnB,YAAlD,EAAgE,EAAEE,cAAF,EAAUD,oBAAV,EAAhE,CAAT;AACD,KAFM,MAEA;AACLmB,eAASF,YAAT;AACD;AACD,WAAQE,WAAWjB,SAAX,iBAA6Ba,IAA7B,sBAAoCC,eAApC,EAAsDG,MAAtD,EAAD,IAAoEJ,IAA3E;AACD,GApBM,EAoBJ,EApBI,CAAP;AAqBD,CAtBD;;AAwBA,IAAMc,wBAAwB,SAAxBA,qBAAwB,SAAU;AACtC,SAAO5B,OAAOE,OAAOC,IAAP,CAAYH,MAAZ,EAAoB,CAApB,CAAP,MAAmC,CAA1C;AACD,CAFD;;AAIO,IAAM6B,sCAAe,SAAfA,YAAe,CAACC,MAAD,EAAS9B,MAAT,EAAiBW,aAAjB,EAAmC;AAC7D,MAAMZ,YAAY6B,sBAAsB5B,MAAtB,CAAlB;AACA,SAAOS,wBAAwBqB,MAAxB,EAAgCnB,aAAhC,EAA+C,EAA/C,EAAmD,EAAEX,cAAF,EAAUD,oBAAV,EAAnD,CAAP;AACD,CAHM;;AAKA,IAAMgC,0CAAiB,SAAjBA,cAAiB,CAACC,UAAD,EAAgB;AAC5C,MAAIC,cAAJ;AAAA,MAAWC,oBAAX;AAAA,MAAwBC,oBAAxB;AACA,MAAMC,cAAeJ,UAAf,yCAAeA,UAAf,CAAN;AACA,MAAII,SAAS,QAAb,EAAuB;AACrBH,YAAQD,WAAWK,KAAX,CAAiB,GAAjB,CAAR;AACAH,kBAAcD,MAAM,CAAN,EAAS3B,UAAT,CAAoB,GAApB,CAAd;AACA6B,kBAAcF,MAAM7B,IAAN,CAAW;AAAA,aAAQkC,KAAKhC,UAAL,CAAgB,GAAhB,MAAyB,CAAC4B,WAAlC;AAAA,KAAX,CAAd;AACAF,iBAAaC,MAAMpB,MAAN,CAAa,UAAC0B,WAAD,EAAcD,IAAd;AAAA,0BACnBC,WADmB,sBACLL,cAAcI,KAAKE,SAAL,CAAe,CAAf,CAAd,GAAkCF,IAD7B,EACqCJ,cAAc,CAAd,GAAkB,CADvD;AAAA,KAAb,EAEV,EAFU,CAAb;AAGD,GAPD,MAOO,IAAIE,SAAS,QAAb,EAAuB;AAC5BH,YAAQ/B,OAAOC,IAAP,CAAY6B,UAAZ,CAAR;AACAE,kBAAcF,WAAWC,MAAM,CAAN,CAAX,MAAyB,CAAvC;AACAE,kBAAcF,MAAM7B,IAAN,CAAW;AAAA,aAAQ4B,WAAWM,IAAX,OAAsBJ,cAAc,CAAd,GAAkB,CAAxC,CAAR;AAAA,KAAX,CAAd;AACD,GAJM,MAIA;AACL,UAAM,IAAIO,KAAJ,CAAU,4CAAV,CAAN;AACD;AACD,MAAIN,WAAJ,EAAiB,MAAM,IAAIM,KAAJ,CAAU,sEAAV,CAAN;AACjB,SAAO,EAAEP,wBAAF,EAAeF,sBAAf,EAAP;AACD,CAnBM","file":"misc.js","sourcesContent":["const shouldRestoreValue = (fullProperty, { exclusive, fields }) => {\r\n  return (exclusive && fields[fullProperty] === 0) ||\r\n    (!exclusive && fields[fullProperty] === undefined &&\r\n      !Object.keys(fields).some(field => field.startsWith(fullProperty)));\r\n};\r\n\r\nconst shouldProcessObjectRecursively = (value, fields, fullProperty) => {\r\n  return typeof (value) === \"object\" && Object.keys(fields).some(field => field.startsWith(fullProperty + \".\"));\r\n};\r\n\r\nconst filterObjectRecursively = (payload, initialObject = {}, rootProperty, { fields, exclusive }) => {\r\n  return Object.keys(payload).reduce((prev, payloadProperty) => {\r\n    const payloadValue = payload[payloadProperty];\r\n    const mergeValue = initialObject[payloadProperty];\r\n    const fullProperty = `${rootProperty ? rootProperty + \".\" : \"\"}${payloadProperty}`;\r\n    let result;\r\n    if (shouldRestoreValue(fullProperty, { fields, exclusive })) {\r\n      result = mergeValue;\r\n    } else if (Array.isArray(payloadValue)) {\r\n      result = payloadValue.map((payloadItem, index) => {\r\n        if (!shouldProcessObjectRecursively(payloadValue, fields, fullProperty)) return payloadItem;\r\n        // Looking row with same id in `initialObject`\r\n        const initialRowObject = mergeValue && mergeValue.find(mergeItem => mergeItem.id === payloadItem.id);\r\n        return filterObjectRecursively(payloadValue[index], initialRowObject, fullProperty, { fields, exclusive });\r\n      });\r\n    } else if (shouldProcessObjectRecursively(payloadValue, fields, fullProperty)) {\r\n      result = filterObjectRecursively(payloadValue, mergeValue, fullProperty, { fields, exclusive });\r\n    } else {\r\n      result = payloadValue;\r\n    }\r\n    return (result !== undefined && { ...prev, [payloadProperty]: result }) || prev;\r\n  }, {});\r\n};\r\n\r\nconst isExclusiveProjection = fields => {\r\n  return fields[Object.keys(fields)[0]] === 0;\r\n};\r\n\r\nexport const filterObject = (object, fields, initialObject) => {\r\n  const exclusive = isExclusiveProjection(fields);\r\n  return filterObjectRecursively(object, initialObject, \"\", { fields, exclusive });\r\n};\r\n\r\nexport const projectionMeta = (projection) => {\r\n  let paths, isExclusive, mixingTypes;\r\n  const type = typeof (projection);\r\n  if (type === 'string') {\r\n    paths = projection.split(' ');\r\n    isExclusive = paths[0].startsWith('-');\r\n    mixingTypes = paths.some(path => path.startsWith('-') === !isExclusive);\r\n    projection = paths.reduce((accumulator, path) => (\r\n      { ...accumulator, [isExclusive ? path.substring(1) : path]: (isExclusive ? 0 : 1) }\r\n    ), {});\r\n  } else if (type === 'object') {\r\n    paths = Object.keys(projection);\r\n    isExclusive = projection[paths[0]] === 0;\r\n    mixingTypes = paths.some(path => projection[path] === (isExclusive ? 1 : 0));\r\n  } else {\r\n    throw new Error('Projection must be either string or object');\r\n  }\r\n  if (mixingTypes) throw new Error('It\\'s not allowed to mix inclusive and exclusive paths in projection');\r\n  return { isExclusive, projection };\r\n};"]}